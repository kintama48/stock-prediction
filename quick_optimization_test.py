#!/usr/bin/env python3
"""
Quick optimization test using the working portfolio simulation
"""

from portfolio_simulation_system import PortfolioSimulation, AllocationStrategy
from pathlib import Path
from datetime import datetime
import pandas as pd

def test_different_strategies():
    """Test different allocation strategies and generate a simple findings report"""
    
    # Create simulation
    simulation = PortfolioSimulation(initial_cash=100000.0)
    
    # Test additional strategies
    strategies = [
        AllocationStrategy("single_best", max_positions=1, max_position_size=0.95),
        AllocationStrategy("dual_best", max_positions=2, max_position_size=0.47),  
        AllocationStrategy("balanced_3", max_positions=3, max_position_size=0.32),
        AllocationStrategy("diversified_5", max_positions=5, max_position_size=0.19),
        
        # Test some variations
        AllocationStrategy("conservative_single", max_positions=1, max_position_size=0.8),
        AllocationStrategy("aggressive_dual", max_positions=2, max_position_size=0.5),
        AllocationStrategy("moderate_triple", max_positions=3, max_position_size=0.3),
    ]
    
    results = []
    
    print("Testing portfolio allocation strategies...")
    
    for strategy in strategies:
        try:
            result = simulation.simulate_strategy(strategy, max_days=100)
            if result:
                results.append(result)
                print(f"{strategy.name}: {result['total_return']:.2%} return, {result['sharpe_ratio']:.3f} Sharpe")
        except Exception as e:
            print(f"Strategy {strategy.name} failed: {e}")
    
    if not results:
        print("No results generated")
        return
    
    # Sort by total return
    results.sort(key=lambda x: x['total_return'], reverse=True)
    
    # Generate findings report
    report_content = f"""# Quick Optimization Test Results

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Strategies Tested:** {len(results)}  

## Results Summary

### Top Performing Strategies

"""
    
    for i, result in enumerate(results):
        report_content += f"""**#{i+1}: {result['strategy']}**
- **Total Return:** {result['total_return']:.2%}
- **Sharpe Ratio:** {result['sharpe_ratio']:.3f}
- **Max Drawdown:** {result['max_drawdown']:.2%}
- **Total Trades:** {result['total_trades']}
- **Days Simulated:** {result['days_simulated']}

"""
    
    # Analysis
    best = results[0]
    worst = results[-1]
    
    report_content += f"""## Key Insights

- **Best Strategy:** {best['strategy']} with {best['total_return']:.2%} return
- **Performance Range:** {worst['total_return']:.2%} to {best['total_return']:.2%}
- **Best Sharpe Ratio:** {best['sharpe_ratio']:.3f} ({best['strategy']})
- **Average Return:** {sum(r['total_return'] for r in results) / len(results):.2%}

## Position Analysis

"""
    
    # Analyze final positions
    for result in results:
        positions = result.get('final_positions', {})
        active_positions = {k: v for k, v in positions.items() if v != 0}
        report_content += f"**{result['strategy']}:** {len(active_positions)} positions - {list(active_positions.keys())}\n"
    
    report_content += f"""

## Next Steps

Based on these results:

1. **Focus on top-performing strategy:** {best['strategy']}
2. **Test variations** of the best strategy with different position sizes
3. **Experiment with rebalancing frequency** for the top strategies
4. **Add risk management** (stop-loss, take-profit) to top performers
5. **Test with more historical data** for better validation

---
*Generated by quick_optimization_test.py*
"""
    
    # Write report
    with open("findings.md", "w") as f:
        f.write(report_content)
    
    print(f"\nResults saved to findings.md")
    print(f"Best strategy: {best['strategy']} with {best['total_return']:.2%} return")

if __name__ == "__main__":
    test_different_strategies()